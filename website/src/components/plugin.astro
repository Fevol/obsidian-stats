---
import { projectRelativeUrl } from '../utils/base';
import GithubLink from './githubLink.astro';
import Commit from './commit.astro';
import Aside from './aside.astro';
import PluginDownloadChart from './svelte/pluginDownloadChart.svelte';
import { getPluginDownloadsWeekly } from '../../../src/plugin/data';
import type { PluginDataInterface } from '../../../src/plugin/plugin';
import fs from 'node:fs/promises';
import type { PluginRepoData } from '../../../src/pluginRepo/types';
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import { Icon } from '@astrojs/starlight/components';

const { plugin } = Astro.props as { plugin: PluginDataInterface };
const pluginDownloadData = getPluginDownloadsWeekly([plugin]);

const latestReleaseDateString = plugin.versionHistory.at(-1)?.initialReleaseDate ?? plugin.addedCommit.date;
const latestReleaseDate = new Date(latestReleaseDateString);

const outdatedDangerThreshold = new Date();
outdatedDangerThreshold.setFullYear(outdatedDangerThreshold.getFullYear() - 1);
const outdatedDanger = latestReleaseDate < outdatedDangerThreshold && !plugin.removedCommit;

const outdatedWarningThreshold = new Date();
outdatedWarningThreshold.setDate(outdatedWarningThreshold.getDate() - 120);
const outdatedWarning = latestReleaseDate < outdatedWarningThreshold && !outdatedDanger && !plugin.removedCommit;

const obsidianLink = `obsidian://show-plugin?id=${plugin.id}`;
const obsidianHubLink = `https://publish.obsidian.md/hub/02+-+Community+Expansions/02.05+All+Community+Expansions/Plugins/${plugin.id}`;
const obsidianAddictLink = `https://obsidianaddict.com/plugin/${plugin.id}/`;

let repoData: PluginRepoData | undefined = undefined;
try {
	const url = projectRelativeUrl(`../pluginRepos/data/${plugin.id}.json`);
	repoData = JSON.parse(await fs.readFile(url, 'utf-8'));
} catch (e) {
	console.log('failed to load repo data');
}

let mismatchedData: string[][] = [];
if (repoData) {
	const dataToCheck = [
		[plugin.currentEntry.name, repoData.manifest.name, 'name'],
		[plugin.currentEntry.author, repoData.manifest.author, 'author'],
		[plugin.currentEntry.description, repoData.manifest.description, 'description'],
	];

	mismatchedData = dataToCheck.filter(x => x[0] !== x[1]);
}

const external_links: { text: string; href: string }[] = [
	repoData?.manifest?.helpUrl ? { text: 'Plugin Docs', href: repoData.manifest.helpUrl } : (undefined as unknown as { text: string; href: string }),
	{ text: 'GitHub Repo', href: plugin.currentEntry.repo },
	{ text: 'View in Obsidian', href: obsidianLink },
	{ text: 'View on ObsidianAddict', href: obsidianAddictLink },
	{ text: 'View on the Obsidian Hub', href: obsidianHubLink },
].filter(Boolean);
---

<StarlightPage
	frontmatter={{
		title: plugin.currentEntry.name,
		description: `Page for the ${plugin.currentEntry.name} plugin.`,
		links: external_links,
	}}
	headings={[
		{ depth: 2, text: 'Data', slug: 'data' },
		{ depth: 3, text: 'Changes', slug: 'changes' },
		{ depth: 3, text: 'Repository Data', slug: 'repository-data' },
		{ depth: 2, text: 'Downloads', slug: 'downloads' },
		{ depth: 2, text: 'Version History', slug: 'version-history' },
	]}
>
	{
		plugin.removedCommit && (
			<Aside variant="danger" title="Plugin has been Removed">
				<p>
					This plugin has been removed from the community list on <Commit commit={plugin.removedCommit} /> and can no longer be installed.
				</p>
			</Aside>
		)
	}

	{
		outdatedWarning && (
			<Aside variant="caution" title="Inactivity Warning">
				<p>The latest version of this plugin was released on the {latestReleaseDateString} and is thus more than 120 days old.</p>
			</Aside>
		)
	}

	{
		outdatedDanger && (
			<Aside variant="danger" title="Inactivity Danger">
				<p>
					The latest version of this plugin was released on the {latestReleaseDateString} and is thus more than a year old. There is a high chance that this
					plugin is no longer maintained.
				</p>
			</Aside>
		)
	}

	<p>{plugin.currentEntry.description}</p>

	<h2 id="data">Data</h2>

	<table class="full-width">
		<tbody>
			<tr>
				<td>ID</td>
				<td>{plugin.id}</td>
			</tr>
			<tr>
				<td>Author</td>
				<td
					>{
						repoData?.manifest.authorUrl ? (
							<a href={repoData?.manifest.authorUrl} target="_blank">
								{plugin.currentEntry.author}
							</a>
						) : (
							plugin.currentEntry.author
						)
					}</td
				>
			</tr>
			{
				repoData?.manifest?.fundingUrl && (
					<tr>
						<td>Funding</td>
						<td>
							<a href={repoData.manifest.fundingUrl}>Support the Author!</a>
						</td>
					</tr>
				)
			}
			{
				repoData && (
					<tr>
						<td>Minimum Obsidian Version</td>
						<td>{repoData.manifest.minAppVersion}</td>
					</tr>
				)
			}
			<tr>
				<td>Official Release Date</td>
				<td><Commit commit={plugin.addedCommit} /></td>
			</tr>
			<tr>
				<td>Last update</td>
				<td>{latestReleaseDateString}</td>
			</tr>
		</tbody>
	</table>

	{
		mismatchedData.length > 0 && (
			<Aside variant="caution" title="Mismatched Data">
				<p>The data in the community list does not match the data in the plugin's repository.</p>
				<table class="full-width">
					<thead>
						<tr>
							<th>Property</th>
							<th>Community List</th>
							<th>Repository</th>
						</tr>
					</thead>
					<tbody>
						{mismatchedData.map(x => (
							<tr>
								<td>{x[2]}</td>
								<td>{x[0]}</td>
								<td>{x[1]}</td>
							</tr>
						))}
					</tbody>
				</table>
			</Aside>
		)
	}

	<h3 class="only-show-small">Quick Links</h3>
	<ul class="only-show-small">
		{
			external_links.map(link => (
				<li>
					<a href="{link.href}" target="_blank">
						{link.text}
					</a>
				</li>
			))
		}
	</ul>

	<h3 id="changes">Changes</h3>

	<table class="full-width">
		<thead>
			<tr>
				<th>Date</th>
				<th>Changed Property</th>
				<th>Old Value</th>
				<th>New Value</th>
			</tr>
		</thead>
		<tbody>
			{
				plugin.changeHistory.map(change => (
					<tr>
						<td>
							<Commit commit={change.commit} />
						</td>
						<td>{change.property}</td>
						<td>{change.oldValue}</td>
						<td>{change.newValue}</td>
					</tr>
				))
			}
		</tbody>
	</table>

	<h3 id="repository-data">Repository Data</h3>

	{
		repoData ? (
			<>
				<table class="full-width">
					<tbody>
						<tr>
							<td>
								License (from <code>package.json</code>)
							</td>
							<td>{repoData.license ?? 'No license found'}</td>
						</tr>
						<tr>
							<td>Package Manager</td>
							<td>{repoData.packageManager ?? 'Unknown (no lock file found)'}</td>
						</tr>
						<tr>
							<td>Uses Typescript</td>
							<td>
								{repoData.usesTypescript ? (
									'true'
								) : (
									<>
										No <code>.ts</code> or <code>.tsx</code> files found
									</>
								)}
							</td>
						</tr>
						<tr>
							<td>Installed Bundlers</td>
							<td>
								{repoData.hasPackageJson ? (
									repoData.installedBundlers.length === 0 ? (
										'none'
									) : (
										repoData.installedBundlers.join(', ')
									)
								) : (
									<>
										No <code>package.json</code> found
									</>
								)}
							</td>
						</tr>
						<tr>
							<td>Installed Testing Frameworks</td>
							<td>
								{repoData.hasPackageJson ? (
									repoData.installedTestingFrameworks.length === 0 ? (
										'none'
									) : (
										repoData.installedTestingFrameworks.join(', ')
									)
								) : (
									<>
										No <code>package.json</code> found
									</>
								)}
							</td>
						</tr>
						<tr>
							<td>Has Test Files</td>
							<td>
								{repoData.hasPackageJson ? (
									repoData.hasTestFiles ? (
										'true'
									) : (
										'false'
									)
								) : (
									<>
										No <code>package.json</code> found
									</>
								)}
							</td>
						</tr>
						<tr>
							<td>Uses BRAT beta releases</td>
							<td>{repoData.hasBetaManifest ? 'true' : 'false'}</td>
						</tr>
						<tr>
							<td>Dependencies</td>
							<td>
								{repoData.hasPackageJson ? (
									repoData.dependencies.sort().join(', ')
								) : (
									<>
										No <code>package.json</code> found
									</>
								)}
							</td>
						</tr>
						<tr>
							<td>Dev Dependencies</td>
							<td>
								{repoData.hasPackageJson ? (
									repoData.devDependencies.sort().join(', ')
								) : (
									<>
										No <code>package.json</code> found
									</>
								)}
							</td>
						</tr>
					</tbody>
				</table>

				<p class="muted">
					<i>Has Test Files</i> looks for files ending in <code>.test.js</code>, <code>.test.ts</code>, <code>.spec.js</code> or <code>.spec.ts</code>.
				</p>
				<p class="muted">
					<i>Installed Testing Frameworks</i> looks at installed dependencies. This does not mean that a plugin is actually using the testing framework.
				</p>
				<p class="muted">
					<i>Dependencies</i> and <i>Dev Dependencies</i> only list the direct dependencies of the plugin.
				</p>
			</>
		) : (
			<p>No data available.</p>
		)
	}

	<h2 id="downloads">Downloads</h2>

	<PluginDownloadChart dataPoints={pluginDownloadData} client:only="svelte" />

	<h2 id="version-history">Version History</h2>

	<table class="full-width">
		<thead>
			<tr>
				<th>Version</th>
				<th>Release Date</th>
			</tr>
		</thead>
		<tbody>
			{
				plugin.versionHistory.map(version => (
					<tr>
						<td>{version.version}</td>
						<td>{version.initialReleaseDate}</td>
					</tr>
				))
			}
		</tbody>
	</table>
</StarlightPage>
