---
import type { PluginRepoData, PluginRepoDataNonNull } from '../../../../src/pluginRepo/types';
import BarChart from '../svelte/genericCharts/barChart.svelte';
import fs from 'node:fs/promises';
import { arrayIntersect, groupBy, multiGroupBy } from '../../../../src/utils';
import type { Licenses } from '../../../../src/license';
import { projectRelativeUrl } from '../../utils/base';

const url = projectRelativeUrl('../pluginRepos/data/');
const repoDataFiles = await fs.readdir(url);

const repoData = (await Promise.all(
	repoDataFiles.map(async file => {
		const content = await fs.readFile(new URL(`./${file}`, url), 'utf-8');
		return JSON.parse(content);
	}),
)) as PluginRepoData[];

const repoDataWithRepos = repoData.filter(x => x.repo !== undefined) as PluginRepoDataNonNull[];

const totalPluginCount = repoDataWithRepos.length;

const licenceInfo = groupBy(repoDataWithRepos, x => x.repo.licenseFile);

const licenceChartInfo = Object.entries(licenceInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const licenceChartSmallInfo = Object.entries(licenceInfo)
	.map(([key, value]) => {
		if (value.length < 100) {
			return {
				label: key,
				value: value.length,
			};
		}
		return undefined;
	})
	.filter(x => x !== undefined)
	.sort((a, b) => b.value - a.value);

const licensePermissions: Record<string, number> = {};
const licenseConditions: Record<string, number> = {};
const licenseLimitations: Record<string, number> = {};

const licenses: Licenses = JSON.parse(await fs.readFile(projectRelativeUrl('../licenses.json'), 'utf-8'));

for (const permission of licenses.permissions) {
	licensePermissions[permission] = 0;
}

for (const condition of licenses.conditions) {
	licenseConditions[condition] = 0;
}

for (const limitation of licenses.limitations) {
	licenseLimitations[limitation] = 0;
}

for (const li of licenceChartInfo) {
	const license = licenses.licenses.find(x => x['spdx-id'] === li.label);
	if (license !== undefined) {
		for (const permission of license.permissions) {
			licensePermissions[permission] += li.value;
		}

		for (const condition of license.conditions) {
			licenseConditions[condition] += li.value;
		}

		for (const limitation of license.limitations) {
			licenseLimitations[limitation] += li.value;
		}
	}
}

const permissionsLabels = Object.keys(licensePermissions).map(x => licenses.descriptions.permissions.find(y => y.tag === x)!.label);
const conditionsLabels = Object.keys(licenseConditions).map(x => licenses.descriptions.conditions.find(y => y.tag === x)!.label);
const limitaionsLabels = Object.keys(licenseLimitations).map(x => licenses.descriptions.limitations.find(y => y.tag === x)!.label);

const packageManagerInfo = groupBy(repoDataWithRepos, x => x.repo.packageManager ?? 'undefined');
const packageManagerChartInfo = Object.entries(packageManagerInfo)
	.map(([key, value]) => {
		if (key === 'undefined') {
			key = 'No Lockfile found';
		}
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const installedBundlersInfo = multiGroupBy(repoDataWithRepos, x => {
	return x.repo.installedBundlers;
});
const installedBundlersChartInfo = Object.entries(installedBundlersInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const installedTestingFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
	return x.repo.installedTestingFrameworks;
});

const installedTestingFrameworksChartInfo = Object.entries(installedTestingFrameworksInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);
const noTestingFrameworkCount = repoDataWithRepos.filter(x => x.repo.installedTestingFrameworks.length === 0).length;

const frontendFrameworks = ['react', 'preact', 'svelte', 'vue', '@angular/core', 'solid-js'];
const installedFrontendFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
	return arrayIntersect([...x.repo.dependencies, ...x.repo.devDependencies], frontendFrameworks);
});

const installedFrontendFrameworksChartInfo = Object.entries(installedFrontendFrameworksInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const noFrontendFrameworkCount = repoDataWithRepos.filter(
	x => arrayIntersect([...x.repo.dependencies, ...x.repo.devDependencies], frontendFrameworks).length === 0,
).length;

const installedToolingFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
	const allDeps = [...x.repo.dependencies, ...x.repo.devDependencies];
	const result = new Set<string>();

	if (allDeps.some(x => x.includes('eslint'))) {
		result.add('eslint');
	}

	if (allDeps.some(x => x.includes('prettier'))) {
		result.add('prettier');
	}

	if (allDeps.some(x => x.includes('@biomejs'))) {
		result.add('biome');
	}

	if (allDeps.some(x => x.includes('dprint'))) {
		result.add('dprint');
	}

	if (x.repo.usesTypescript) {
		result.add('typescript');
	}

	return Array.from(result);
});

const installedToolingFrameworksChartInfo = Object.entries(installedToolingFrameworksInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const mostUsedDepsInfo = multiGroupBy(repoDataWithRepos, x => {
	return [...x.repo.dependencies, ...x.repo.devDependencies];
});

const mostUsedDepsChartInfo = Object.entries(mostUsedDepsInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => b.value - a.value);

const limitedMostUsedDepsChartInfo = mostUsedDepsChartInfo.filter(x => x.value / totalPluginCount >= 0.01);

const hasBetaManifestInfo = groupBy(repoDataWithRepos, x => x.repo.hasBetaManifest.toString());
const hasBetaManifestChartInfo = Object.entries(hasBetaManifestInfo)
	.map(([key, value]) => {
		return {
			label: key,
			value: value.length,
		};
	})
	.sort((a, b) => a.label.length - b.label.length);
---

<h3>License Usage</h3>

<p>The licenses of plugins are processed to collapse synonyms for the same license into one.</p>

<p>
	The following chart shows the distribution of licenses in the plugins. The information is based on the identified <code>LICENSE</code> files in the repositories.
	Identification of those file may not be accurate.
</p>

<p>
	<code>not found</code> means that a no license file was found in the repository. 
	Obsidian <a href="https://docs.obsidian.md/Developer+policies#Copyright+and+licensing" target="_blank">requires a license file to be present</a> for new plugins, but this is not enforced retroactively.
</p>

<p>
	<code>unknown</code> means that a license file was found, but the license could not be identified.
</p>

<BarChart
	dataPoints={licenceChartInfo.map(x => x.value)}
	labels={licenceChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<p>Licenses that are used by more than 100 plugins are excluded from the chart below.</p>

<BarChart
	dataPoints={licenceChartSmallInfo.map(x => x.value)}
	labels={licenceChartSmallInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<h3>License Terms</h3>

<p>The following charts show the distribution of license terms in the plugins. The terms are based on the licenses shown in the charts above.</p>

<h4>Permissions</h4>

<p>A number of plugins give the following permissions.</p>

<BarChart
	dataPoints={Object.values(licensePermissions)}
	labels={permissionsLabels}
	aspectRatio={2}
	logScale={false}
	seriesName="Number of Plugins"
	client:only="svelte"
/>

{
	licenses.descriptions.permissions.map(x => (
		<p>
			<strong>{x.label}</strong>: {x.description}
		</p>
	))
}

<h4>Conditions</h4>

<p>A number of plugins impose the following conditions.</p>

<BarChart
	dataPoints={Object.values(licenseConditions)}
	labels={conditionsLabels}
	aspectRatio={2}
	logScale={false}
	seriesName="Number of Plugins"
	client:only="svelte"
/>

{
	licenses.descriptions.conditions.map(x => (
		<p>
			<strong>{x.label}</strong>: {x.description}
		</p>
	))
}

<h4>Limitations</h4>

<p>A number of plugins impose the following limitations.</p>

<BarChart
	dataPoints={Object.values(licenseLimitations)}
	labels={limitaionsLabels}
	aspectRatio={2}
	logScale={false}
	seriesName="Number of Plugins"
	client:only="svelte"
/>

{
	licenses.descriptions.limitations.map(x => (
		<p>
			<strong>{x.label}</strong>: {x.description}
		</p>
	))
}

<h3>BRAT Beta Manifest Usage</h3>

<p>The percentage of plugins that have a BRAT beta manifest.</p>

<BarChart
	dataPoints={hasBetaManifestChartInfo.map(x => x.value)}
	labels={hasBetaManifestChartInfo.map(x => x.label)}
	logScale={false}
	aspectRatio={2}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<h3>Dependencies</h3>

<h4>Package Managers Used</h4>

<p>The distribution of package managers used in plugins. The package manager is determined by the presence of a lockfile in the plugin repository.</p>

<BarChart
	dataPoints={packageManagerChartInfo.map(x => x.value)}
	labels={packageManagerChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<h4>Code Bundler Usage</h4>

<p>
	The distribution of code bundlers used in plugins. The bundler is determined by the presence of dependencies in the plugins <code>package.json</code>.
</p>

<BarChart
	dataPoints={installedBundlersChartInfo.map(x => x.value)}
	labels={installedBundlersChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<h4>Developer Tooling Usage</h4>

<p>The distribution of developer tooling used in plugins.</p>

<BarChart
	dataPoints={installedToolingFrameworksChartInfo.map(x => x.value)}
	labels={installedToolingFrameworksChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<h4>Testing Framework Usage</h4>

<p>
	The distribution of testing frameworks used in plugins. The testing frameworks usage is determined by the presence of dependencies in the plugins <code
		>package.json</code
	>.
</p>

<BarChart
	dataPoints={installedTestingFrameworksChartInfo.map(x => x.value)}
	labels={installedTestingFrameworksChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<p>
	{noTestingFrameworkCount} ({((noTestingFrameworkCount * 100) / totalPluginCount).toFixed(2)}%) plugins use no testing framework.
</p>

<h4>Frontend Framework Usage</h4>

<p>
	The distribution of frontend frameworks used in plugins. The frontend frameworks usage is determined by the presence of dependencies in the plugins <code
		>package.json</code
	>.
</p>

<BarChart
	dataPoints={installedFrontendFrameworksChartInfo.map(x => x.value)}
	labels={installedFrontendFrameworksChartInfo.map(x => x.label)}
	logScale={false}
	seriesName="Number of Plugins"
	calculatePrecentages={true}
	percent100={totalPluginCount}
	client:only="svelte"
/>

<p>
	{noFrontendFrameworkCount} ({((noFrontendFrameworkCount * 100) / totalPluginCount).toFixed(2)}%) plugins use no frontend framework.
</p>

<h4>Most Used Dependencies</h4>

<p>
	This table shows direct dependencies of all plugins, sorted by how many plugins use them. Dependencies with less than one percent usage are not shown.
</p>

<table>
	<thead>
		<tr>
			<th> Name</th>
			<th> Usage Count</th>
			<th> Usage Percentage</th>
		</tr>
	</thead>
	<tbody>
		{
			limitedMostUsedDepsChartInfo.map(x => (
				<tr>
					<td>{x.label}</td>
					<td>{x.value}</td>
					<td>{((x.value * 100) / totalPluginCount).toFixed(2)}%</td>
				</tr>
			))
		}
	</tbody>
</table>
